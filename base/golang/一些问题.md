### 函数参数何时通过值传递？

与C系列中的所有语言一样，Go中的所有内容都按值传递。也就是说，函数总是获取正在传递的东西的副本，就好像有一个赋值语句将值赋给参数。例如，将`int`值传递给函数会生成一个副本`int`，并且传递指针值会生成指针的副本，但不会生成它指向的数据。（有关如何影响方法接收器的讨论，请参阅[后面的部分](http://docs.studygolang.com/doc/faq#methods_on_values_or_pointers)。）

映射和切片值的行为类似于指针：它们是包含指向底层映射或切片数据的指针的描述符。复制地图或切片值不会复制它指向的数据。复制接口值会生成存储在接口值中的事物的副本。如果接口值包含结构，则复制接口值会生成结构的副本。如果接口值包含指针，则复制接口值会生成指针的副本，但同样不会指向它指向的数据。

请注意，此讨论是关于操作的语义。只要优化不改变语义，实际实现可以应用优化以避免复制。

### 为什么T和* T有不同的方法集？

正如[Go规范](http://docs.studygolang.com/ref/spec#Types)所说，类型的方法集`T`包含所有具有接收器类型的方法`T`，而相应指针类型`*T`的方法包含所有带接收器`*T`或 方法的方法`T`。这意味着方法集`*T` 包括`T`但不反过来。

之所以出现这种区别是因为如果接口值包含指针`*T`，则方法调用可以通过取消引用指针来获取值，但是如果接口值包含值`T`，则方法调用无法获得指针的安全方法。（这样做会允许方法修改接口内部值的内容，这是语言规范所不允许的。）

即使在编译器可以将值的地址传递给方法的情况下，如果方法修改了值，则更改将在调用者中丢失。作为一个例子，如果该`Write`方法 [`bytes.Buffer`](http://docs.studygolang.com/pkg/bytes/#Buffer) 中使用的值接收器，而不是一个指针，这样的代码：

```
var buf bytes.Buffer
io.Copy（buf，os.Stdin）
```

将标准输入复制到*副本*中`buf`，而不是*复制*到`buf`自身中。这几乎不是理想的行为。

### 为什么我的nil错误值不等于nil？

在封面下，接口实现为两个元素，一个类型`T` 和一个值`V`。 `V`是一个具体的值，例如一个`int`， `struct`或指针，从未接口本身，和具有类型`T`。例如，如果我们将`int`值3 存储在接口中，则生成的接口值示意性地具有（`T=int`，`V=3`）。该值`V`也称为接口的 *动态*值，因为给定的接口变量在程序执行期间可能包含不同的值`V` （和相应的类型`T`）。

接口值`nil`仅在`V`和`T` 未设置时（`T=nil`，`V`未设置），特别是`nil`接口始终保持`nil`类型。如果我们在接口值中存储`nil`类型的指针`*int`，则内部类型将`*int`与指针的值无关:( `T=*int`，`V=nil`）。因此，`nil` *当V内部指针值为时，* 这样的接口值将是非*偶数的*`nil`。

这种情况可能会令人困惑，并且当`nil`值存储在接口值（如`error`return）中时会出现：

```go
func returnsError() error {
	var p *MyError = nil
	if bad() {
		p = ErrBad
	}
	return p // Will always return a non-nil error.
}
```

如果一切顺利，函数返回a `nil` `p`，所以返回值是一个`error`保持（`T=*MyError`，`V=nil`）的接口值。这意味着如果调用者将返回的错误`nil`与之比较，即使没有发生任何错误，也总是看起来好像有错误。要将一个正确`nil` `error`的函数返回给调用者，该函数必须返回一个显式`nil`：

```go
func returnsError() error {
	if bad() {
		return ErrBad
	}
	return nil
}
```

对于返回错误的函数总是`error`在其签名中使用类型（如上所述）而不是具体类型（例如`*MyError`，以帮助保证正确创建错误），这是一个好主意。举个例子， 即使不是，也要[`os.Open`](http://docs.studygolang.com/pkg/os/#Open) 返回一个具体的类型 。 `error``nil`[`*os.PathError`](http://docs.studygolang.com/pkg/os/#PathError)

每当使用接口时，都会出现与此处描述的情况类似的情况。请记住，如果界面中存储了任何具体值，则界面将不会存在`nil`。有关更多信息，请参阅 [反思定律](http://docs.studygolang.com/doc/articles/laws_of_reflection.html)。