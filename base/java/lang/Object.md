## Object

Class Object是类层次结构的根。 每个类都有Object作为超类。 所有对象（包括数组）都实现此类的方法。

Object里面的方法一共有**12**个，一个静态native方法`registerNative`在Object类被加载的时候就会通过静态代码块
执行方法。剩下11最基本的个方法。

`clone()`:

创建并返回此对象的副本。 “复制”的确切含义可能取决于对象的类别。一般意图是，对于任何对象x，表达式：

    x.clone（）!= x(也就是说会返回一个新的对象)
    
    x.clone（）。getClass（）== x.getClass（）（返回的对象应该通过调用super.clone来获得,而不是创建了另一个类型的对象返回，并非绝对要求。虽然通常情况是：）


    x.clone().equals(x) （并非绝对要求。）

按照惯例，此方法返回的对象应独立于此对象（正在克隆）。要实现此独立性，可能需要在返回之前修改super.clone返回的对象的一个​​或多个字段。
通常，这意味着复制包含被克隆对象的内部“深层结构”的任何可变对象，并使用对副本的引用替换对这些对象的引用。如果一个类只包含原始字段或对不可变对象的引用，
那么通常情况下，super.clone返回的对象中的任何字段都不需要修改。

类Object的方法clone执行特定的克隆操作。首先，如果此对象的类未实现Cloneable接口，则抛出CloneNotSupportedException。
请注意，所有数组都被认为是实现Cloneable接口，并且数组类型T []的clone方法的返回类型是T []，其中T是任何引用或基本类型。另外，此方法创建此对象的类的新实例，
并使用该对象的相应字段的内容初始化其所有字段，就像通过赋值一样;这些字段的内容本身不会被克隆。因此，该方法执行该对象的“浅拷贝”，而不是“深拷贝”操作。

Object类本身并不实现Cloneable接口，因此在类为Object的对象上调用clone方法将导致在运行时抛出异常。

上面需要注意的是**浅拷贝**与**深拷贝**，如果我们不重写`clone()`，
那么返回对象里面的对象字段的引用还是和被拷贝的对象里面的引用是一样的。这意味着，修改了克隆来的对象的字段值，
被克隆对象里面的字段值也会被更改，这就是浅拷贝。如果不想这样，可以重写`clone()`调用`super.clone()`先创建一个新的对象，
然后为这个对象里引用字段创建一个新的对象，这样就可以实现深拷贝。

`getClass()`:

返回此Object的运行时类。 返回的Class对象是由所表示的类的静态同步方法锁定的对象。这个方法一般在反射中使用。

`finalize()`

这个方法，在java 11中已经被标记为废弃。它类似`C++`里面的析构函数，在对象被垃圾回收器回收的时候执行的，
但是事实上，它被执行的时间点并不确定，在不同的JVM里面也可能有不同的表现。所以它并不可靠，而且性能损耗很高。
在java里也没有多大的用处。《Effective Java》里面提到不是完全没有，如果当一个对象所有者忘记关闭了需要显示关闭的对象，比如一个数据库的连接，
这时候`finalize()`就可以充当一个安全网来关闭资源，或者是一个对象的本地对等体有关，就是说普通对象通过一个本地方法委托给了一个本地对象，
这时候垃圾回收器是感觉不到这个本地对象的，在本地对象不拥有关键资源的情况下，`finalize()`方法是回收它的最佳选择。
不过既然java 11里标记它已经被废弃，估计这两点已经被其他的方法解决了，`finalize()`现在是一点用都没有了，


`wait()` ，`wait​(long timeoutMillis)`，`wait​(long timeoutMillis)`，`wait​(long timeoutMillis)` 与 `notify()`,`notifyAll()`

这两个方法，在处理线程问题的时候会被用到。他们的执行需要获得当前对象的锁。


`toString()`

一个类的自我描述

`equals()`

判断对象是否相等


`hashCode()`

返回此对象的hash码，重写`equal()`方法的时候别忘了也重写这个方法，要不在使用map的时候。
或者明明放进去了一个对象，但是你获取不到这个对象，这种情况增多进而发生内存泄漏。



